<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="description" content="A gopher who&#39;s using VIM">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="generator" content="Hugo 0.21" />
    <meta name="robots" content="index,follow">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://namhuynhvo.github.io/dist/styles.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,400,600,700,300&subset=latin,cyrillic-ext,latin-ext,cyrillic">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link href="https://namhuynhvo.github.io/index.xml" rel="alternate" type="application/rss+xml">
</head>

<body>

    <div id="wrapper">

        <header class="site-header">
            <div class="container">
                <a href="https://namhuynhvo.github.io">
                    <img src="https://namhuynhvo.github.io/images/main/main_logo.png" class="post-img">
                </a>
            </div>
        </header>

        <div id="container">
            <div id="post-index" class="container" itemscope="" itemtype="https://schema.org/Blog">
                <header class="post-header">
                    <h1>#giao thức zrtp</h1>
                    <p class="post-date">
                        <time datetime="2018-09-03">Published Monday, Sep 03, 2018</time>
                    </p>
                </header>
                <div class="post-content clearfix" itemprop="articleBody">
                    <h1 class="post-color">Một số khái niệm</h1>

                    <ul>
                        <li>ZRTP - Zimmerman Real-Time Transport
                            <br>
                        </li>
                    </ul>

                    <p>ZRTP là giao thức an ninh dựa trên nền tảng giao thức RTP (Real Time Protocol) / SRTP (Secure RTP) được thiết kế phát triển bởi Phil Zimmermann đặc biệt cho ứng dụng VoIP ZRTP là một giao thức thỏa thuận khóa (key-agreement) giữa 2 điểm đầu cuối, các khóa này sẽ được sử dụng để mã hóa thông tin truyền giữa 2 điểm này trong cuộc gọi VoIP dựa trên RTP. ZRTP sử dụng giao thức trao đổi khóa DiffieHellman và SRTP để mã hóa dữ liệu ZRTP không cần mã bí mật chia sẽ trước hoặc giữa trên kỹ thuật mã hóa khóa công cộng mà mỗi key Diffie-Hellman được tạo riêng cho mỗi session. Bản chất của ZRTP độc lập với giao thức báo hiệu vì sử dụng RTP để trao đổi key nên ZRTP có thể được sử dụng kết hợp với nhiều giao thức VoIP (SIP, H.323, Jingle...) nếu các giao thức đó sử dụng RTP để truyền media.</p>

                    <ul>
                        <li>RTP - Real Time Protocol
                            <br>
                        </li>
                    </ul>

                    <p>RTP (Giao thức vận chuyển thời gian thực) đặc tả một tiêu chuẩn định dạng gói tin dùng để truyền âm thanh và hình ảnh qua internet (Tiêu chuẩn RFC 1889). Nó được phát triển bởi nhóm Audio Video Transport Working và được ban hành lần đầu tiên vào năm 1996. Giao thức RTP (Realtime Transport Protocol) cung cấp các chức năng giao vận phù hợp cho các ứng dụng truyền dữ liệu mang đặc tính thời gian thực như là thoại và truyền hình tương tác. Những dịch vụ của RTP bao gồm trường chỉ thị loại tải trọng (payload identification), đánh số thứ tự các gói, điền tem thời gian (phục vụ cho cơ chế đồng bộ khi phát lại tín hiệu ở bên thu)… Thông thường các ứng dụng chay giao thức RTP ở bên trên giao thức UDP để sử dụng các dịch vụ ghép kênh (mutiplexing) và kiểm tra tổng (checksum) của dịch vụ này; cả hai giao thức RTP và UDP tạo nên một phần chức năng của giao thức tầng giao vận. Tuy nhiên RTP cũng có thể được sử dụng với những giao thức khác của tầng mạng và tầng giao vận bên dưới miễn là các giao thức này cung cấp được các dịch vụ mà RTP đòi hỏi: giao thức RTP hỗ trợ việc truyền dữ liệu tới nhiều đích sử dụng phân bố dữ liệu multicast nếu như khả năng này được tầng mạng hoạt động bên dưới nó cung cấp. Một điều cần lưu ý là bản thân RTP không cung cấp một cơ chế nào đảm bảo việc phân phát kịp thời dữ liệu tới các trạm mà nó dựa trên các dịch vụ của tầng thấp hơn để thực hiện điều này. RTP cũng không đảm bảo việc truyền các gói theo đúng thứ tự. Tuy nhiên số thứ tự trong RTP header cho phép bên thu xây dựng lại thứ tự đúng của các gói bên phát.</p>

                    <ul>
                        <li>SRTP - Secure RTP
                            <br>
                        </li>
                    </ul>

                    <p>SRTP (Giao thức bảo mật vận tải thời gian thực) là một mô tả sơ lược của RTP (Tiêu chuẩn RFC 3711) để cung cấp tính bảo mật, tính toàn vẹn và xác thực thông báo trong môi trường truyền thông (tiếng nói và hình ảnh). SRTP bảo đảm an toàn cho cả các gói tin RTP và các thông báo RTCP. RTCP được sử dụng trước tiên để cung cấp sự phản hồi QoS đến các điểm đầu cuối của phiên liên lạc. Các thông báo RTCP được truyền tách riêng khỏi các thông báo RTP, cho nên cả RTP và RTCP đều cần được bảo vệ trong suốt phiên liên lạc trong môi trường đa phương tiện. Bằng việc sử dụng thuật toán dẫn xuất khoá nguyên thuỷ, SRTP có khả năng tối thiểu hoá tính toán và sử dụng tài nguyên để sinh các khoá mật mã qua cơ chế quản lý khoá ngoài. Mặc dù SRTP có thể cung cấp tính bảo mật, tính toàn vẹn và xác thực đối với thông báo được truyền đi, nhưng nó không thể duy trì toàn vẹn và xác thực thông báo từ đầu cuối đến đầu cuối cho các liên lạc được truyền từ mạng IP đến mạng PSTN.</p>

                    <h1 class="post-color">Định dạng bản tin ZRTP</h1>

                    <img class="post-content" src="https://namhuynhvo.github.io/images/post/2/dinh-dang-bang-tin.png" />

                    <ul>
                        <li>Trường sequence Number (số thự tự) là một số đếm, được tăng lên khi mỗi gói ZRTP gửi đi. Số đếm này được khởi tạo là một số ngẫu nhiên.Mục đích để ước lượng gói bị mất và để phát hiện gói ZRTP đến không đúng thứ tự.
                            <br>
                        </li>
                        <li>ZRTP magic Cookie là một chuỗi 32 bit dùng để nhận dạng gói ZRTP và có giá trị 0x5a525450.
                            <br>
                        </li>
                        <li>Source Indentifier là một số SSRC của luồng ZRTP để thay thế các gói ZRTP.
                            <br>
                        </li>
                        <li>Trường ZRTP message: ZRTP sử dụng một block 8 octet (2 word) để mã hóa loại bản tin (message type). Khối 4 octet sử dụng để mã hóa hash Type (loại băm), cipher type (loại bản mã), key agreement type (loại trao đổi khóa) và authentication tag type. Các giá trị trong các khối là một chuỗi ASCII.
                            <br>
                        </li>
                        <li>Trường CRC sử dụng 32 bit CRC để phát hiện lỗi.
                            <br>
                        </li>
                    </ul>

                    <p>Như đã trình bày ở trên, xác thực ZRTP sử dụng chuỗi xác thực ngắn SAS (short authentication string). SAS type xác đinh SAS nào bị trả lại người sử dụng, vì thế người sử dụng có thể so sánh bằng lời với đối tác qua kênh thoại. Điều này cho phép phát hiện tấn công MiTM.</p>

                    <p>Điều này cho phép phát hiện tấn công MiTM. Tất cả các điểm cuối ZRTP phải được hỗ trợ base32 và có thể hỗ trợ base256. Các kiểu SAS:</p>

                    <img class="post-content" src="https://namhuynhvo.github.io/images/post/2/cac-kieu-sas.png" />

                    <h1 class="post-color">Cách thức hoạt động của ZRTP</h1>
                    <p>Khi ZRTP được sử dụng để thiết lập phiên SRTP, nó được phân làm 4 giai đoạn:</p>

                    <ul>
                        <li>Giai đoạn khởi tạo phiên RTP: sử dụng giao thức khởi tạo phiên.Cả hai điểm cuối ZRTP bắt đầu trao đổi ZRTP bằng việc gửi một bản tin "hello" ZRTP tới điểm cuối khác. Mục đích của bản tin "hello" là để xác nhận rằng điểm cuối hỗ trợ giao thức ZRTP không và để biết được thuật toán chung giữa hai điểm cuối ZRTP.
                            <br>
                        </li>
                        <li>Giai đoạn thỏa thuận: Sau khi cả hai điểm cuối trao đổi bản tin "hello" và bản tin "helloACK", quá trình thỏa thuận khóa bắt đầu với bản tin "commit" ZRTP. ZRTP hỗ trợ một số chế độ thỏa thuận khóa bao gồm chế độ Diff-hellman và chế độ non-Diff-Hellman. Bản tin "commit" có thể được gửi ngay sau khi hoàn thành quá trình bắt tay (hello/helloACK).
                            <br>
                        </li>
                        <li>Giai đoạn trao đổi khóa Diff-Hellman.
                            <br>
                        </li>
                        <li>Giai đoạn xác thực (xác nhận quá trình trao đổi khóa thành công): xác thực ZRTP sử dụng chuỗi xác thực ngắn SAS (short authentication string). Ngoài ra, SAS có thể được xác thực bằng việc trao đổi chữ ký số (sig) qua SAS trong bản tin confirm1 hoặc confirm2:
                            <br>
                        </li>
                    </ul>

                    <img class="post-content" src="https://namhuynhvo.github.io/images/post/2/cach-thuc-hoat-dong.png" />

                    <ul>
                        <li>Alice và Bob khởi tạo ZRTP trên cồng truyền tin media:
                            <ul>
                                <li>Alice gửi bản tin "Hello" tới Bob trên khung F1 (bản tin này chứa phiên bản, tùy chọn và ZID của Alice), Bob gửi xác nhận bằng bản tin "helloAck" trên khung F2 (bản tin này chứa phiên bản, tùy chọn và ZID của Bob).
                                </li>
                                <li>Hoặc Bob gửi bản tin "Hello" tới Alice trên khung F3, Alice nhận được bản tin "Hello" và gửi xác nhận bằng bản tin "helloAck" trên khung F4.
                                </li>
                            </ul>
                        </li>
                        <li>Xét trường hợp Bob thiết lập liên lạc với Alice:
                            <ul>
                                <li>Bob gửi bản tin "commit" tới Alice trên khung F5 (bản tin commit chứa ZID của Bob, các tùy chọn và giá trị băm).
                                </li>
                                <li>Alice gửi lại cho Bob bản tin "DHpart1" trên khung F6 (bản tin này chứa pvr, hàm băm bí mật chung giữa Alice và Bob).
                                </li>
                                <li>Bob gửi lại cho Alice bản tin "DHpart2" trên khung F7 (bản tin này chứa pvi, hàm băm bí mật chung giữa Alice và Bob).
                                </li>
                            </ul>
                        </li>
                        <li>Alice và Bob tạo khóa phiên SRTP:
                            <ul>
                                <li>Alice gửi cho Bob bản tin "confirm1" trên khung F8 (bản tin này chứa MAC, cờ D (disclosure), A (allow clear), V (SAS verified), E(enrollment) , sig). Bob gửi cho Bob bản tin "confirm2" trên khung F9 (bản tin này chứa MAC, cờ D, A, V, E, sig).
                                </li>
                                <li>Alice gửi lại cho Bob bản tin "conf2Ack". Quá trình SRTP bắt đầu.
                                </li>
                            </ul>
                        </li>
                    </ul>

                    <h1 class="post-color">Đặc tính khóa của ZRTP</h1>

                    <ul>
                        <li>Xác thực:
                            <br>
                        </li>
                    </ul>

                    <p>Để ngăn chặn tấn công MiTM, ZRTP sử dụng chuỗi xác thực ngắn (SASShort authentication String). SAS là giá trị băm mật mã của hai giá trị công khai của thuật toán DiffHellman. SAS được tạo ra trên cả hai phía người sử dụng.</p>

                    <p>Để thực hiện chứng thực, cả hai phía người dùng sẽ phải đọc to giá trị SAS được tính toán thông qua kết nối bằng giọng nói đã thiết lập. Nếu giá trị trên cả hai đầu cuối của kết nối voice bằng nhau nó chỉ ra các thực thể tham gia sử dụng khóa giống nhau để mã hóa. Nếu có cuộc tấn công MiTM trên kết nối voice sẽ có các khóa mật khác nhau ở hai đầu cuối nghĩa là khóa mật giữa người khởi tạo và người còn lại đã bị tấn công.</p>

                    <ul>
                        <li>Khóa liên tục:
                            <br>
                        </li>
                    </ul>

                    <p>Khi tính năng "baby duck security" được sử dụng để xác thực quá trình trao đổi khóa Diff-Hellman. Tất cả người dùng tham gia vào cuộc thông tin liên lạc voice đều phải lưu lại khóa bí mật được chia sẻ mà đã sử dụng trong phiên liên lạc, khóa này sử dụng tính toán khóa chia sẻ trong phiên liên lạc tiếp theo để nhận giá trị khóa Diff-Hellman mới. Điều này nói lên rằng để tiến hành một cuộc tấn công MiTM thì kẻ tấn công phải có mặt trong tất cả các phiên họp bắt đầu từ phiên họp đầu tiên, quá trình này gây khó khăn cho kẻ tấn công.</p>

                    <ul>
                        <li>Khả năng tấn công MiTM:
                            <br>
                        </li>
                    </ul>

                    <p>Mặc dù các biện pháp đối phó với phương pháp tấn công MiTM đã đề cập ở trên, tuy nhiên ZRTP vẫn có khẳ năng bị tấn công MiTM: kẻ tấn công vẫn có khả năng đột nhập vào đường dẫn dữ liệu bằng cách nào đó như: tấn công giả mạo ARP giữa nạn nhân Alice và SIP máy chủ Proxy.</p>

                    <h1 class="post-color">Thuật toán trao đổi khóa Diffie-Hellman</h1>
                    <p>Phương pháp trao đổi khóa Diffie–Hellman cho phép hai bên (người, thực thể giao tiếp) thiết lập một khóa bí mật chung để mã hóa dữ liệu sử dụng trên kênh truyền thông không an toàn mà không cần có sự thỏa thuận trước về khóa bí mật giữa hai bên. Khóa bí mật tạo ra sẽ được sử dụng để mã hóa dữ liệu với phương pháp mã hóa khóa đối xứng.</p>

                    <ul>
                        <li>Mô tả thuật toán:
                            <br>
                        </li>
                    </ul>

                    <p>Alice và Bob muốn tạo ra một khóa mật sử dụng chung để mã hóa và giải mã dữ liệu bằng một thuật toán mật mã đối xứng nào đó. Trước hết Alice và Bob thỏa thuận với nhau hai số nguyên lớn q và g (không cần giữ bí mật các số này). Sau đó Alice và Bob thực hiện như sau:

                        <p>+ Alice: Chọn số nguyên XA nào đó. Yêu cầu: XAAlice. Tính giá trị YA=gXAmod q, YA là khóa chung của Alice. Gửi YA cho Bob và nhận YB từ Bob. Tính KA = YBXAmod q.</p>

                        <p>+ Bob: Chọn số nguyên XB nào đó. Yêu cầu: XBBob. Tính giá trị YB=gXAmod q, YB là khóa chung của Bob. Gửi YB cho Alice và nhận YA từ Alice. Tính KB = YAXBmod q Điều đặc biệt là YBXAmod q = YAXBmod q hay KA=KB=K Do đó Alice và Bob có thể dùng K làm khóa phiên cho phiên liên lạc bằng một thuật toán mã hóa đối xứng nào đó.</p>

                        <ul>
                            <li>Nhận xét:
                                <br>
                            </li>
                        </ul>

                        <p>Việc Bob giải được khóa riêng tư của Alice, và Alice giải được khóa riêng tư của Bob phải là bài toán khó đối với cả hai. Nếu bài toán tìm khóa riêng tư của Bob không khó đối với Alice (hoặc ngược lại), thì Eve (kẻ tấn công hay hacker) chỉ cần thay thế cặp khóa riêng tư / công khai của mình, gắn khóa công khai của Bob vào khóa riêng tư của mình, tạo ra khóa bí mật chia sẻ giả, và giải ra khóa riêng tư của Bob, sau đó sử dụng nó để tìm ra khóa bí mật chia sẻ giữa Bob và Alice. Eve cũng có thể tìm cách chọn cặp khóa công khai / riêng tư nào đó giúp Eve giải được khóa riêng tư của Bob một cách dễ dàng.</p>

                        <h1 class="post-color">Kết luận</h1>
                        <p>ZRTP là một giao thức thỏa thuận khóa (key-agreement) giữa 2 điểm cuối trong cuộc gọi VoIP dựa trên RTP. Mặc dù sử dụng thuật toán khóa công khai nhưng nó tránh được sự phức tạp của cơ sở hạ tầng khóa công khai (PKI). Trong thực tế, nó không sử dụng khóa công khai dai dẳng trong tất cả phiên liên lạc. Nó sử dụng tạm thời một khóa phiên theo thuật toán Diffie-Hellman cho phép phát hiện các cuộc tấn công (MiTM) bằng cách hiển thị một chuỗi xác thực ngắn cho người sử dụng bằng lời nói so sánh qua điện thoại, có nghĩa là khóa này sẽ bị hủy vào cuối cuộc gọi, điều này nhằm loại bỏ các yếu tố ảnh hưởng đến các cuộc gọi trong tương lai. Nhưng ngay cả khi người sử dụng không để ý tới các chuỗi xác thực ngắn, thì việc xác thực vẫn được thực hiện dựa trên hình thức khóa liên tục, nghĩa là một vài khóa được lưu trong bộ đệm và được sử dụng cho các cuộc gọi tiếp theo. Các khóa này được trộn lẫn với các cuộc gọi tiếp theo và có chức năng tương tự như các cơ quan chứng nhận để xác thực cuộc gọi VoIP. Tất cả điều này được thực hiện mà không phụ thuộc vào cơ sở hạ tầng khóa công khai (PKI), chứng nhận khóa, mô hình tin cậy, hoặc sự phức tạp trong quản lý khóa. Nó cũng không dựa trên dấu hiệu SIP cho việc quản lý khóa, trong thực tế nó không dựa trên bất kỳ máy chủ nào cả. Nó thực hiện các thỏa thuận khóa và quản lý khóa một cách hoàn toàn ngang hàng thông qua các gói RTP.</p>

                        <p><em>Chữ viết tắt:<em></p>
                    <ul>
                        <li><em>ZRTP: Zimmerman Real-Time Transport
                            </em>
                            </li>
                            <li><em>SRTP: Secure Real-Time Transport
                            </em>
                            </li>
                            <li><em>SAS: Short Authentication String
                            </em>
                            </li>
                            <li><em>PKI: Public Key Infrastructure
                            </em>
                            </li>
                            <li><em>MiTM: Man In The Middle Attack
                            </em>
                            </li>
                            </ul>

                            <p style="text-align: right;"><em>huynh nam by <a href="https://www.rfc-editor.org/info/rfc6189" style="color: #ff0000; data-wpel-link="external" target="_new" rel="nofollow">P. Zimmermann
                      A. Johnston, Ed.
                      J. Callas</a></em></p>

                      <script src="https://utteranc.es/client.js"
                            repo="namhuynhvo/namhuynhvo.github.io"
                            issue-term="pathname"
                            theme="github-light"
                            crossorigin="anonymous"
                            async>
                    </script>

                </div>
                <div class="post-navigation">
                </div>
            </div>
        </div>
    </div>

    <footer class="footer">
        <div class="container">
            <div class="site-title-wrapper">
                <a class="button-jump-top js-jump-top" href="#">
                    <img src="https://namhuynhvo.github.io/images/main/main_logo.png" class="post-img-footer">
                </a>
            </div>
            <p class="footer-copyright">
                <script id="_waudcy">var _wau = _wau || []; _wau.push(["dynamic", "2sqjowgh0z", "dcy", "666666ffffff", "small"]);</script><script async src="//waust.at/d.js"></script>
            </p>
            <p class="footer-copyright">
                <span>&copy; 2018 / Powered by <a href="https://gohugo.io/">Hugo</a></span>
            </p>
            <p class="footer-copyright">
                <span><a href="https://github.com/roryg/ghostwriter">Ghostwriter theme</a> By <a href="http://jollygoodthemes.com">JollyGoodThemes</a></span>
                <span>/ <a href="https://github.com/jbub/ghostwriter">Ported</a> to Hugo By <a href="https://github.com/jbub">jbub</a></span>
            </p>
        </div>
    </footer>

    <script src="https://namhuynhvo.github.io/js/jquery-1.11.3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
    <script src="https://namhuynhvo.github.io/js/jquery.fitvids.js"></script>
    <script src="https://namhuynhvo.github.io/js/scripts.js"></script>
</body>

</html>